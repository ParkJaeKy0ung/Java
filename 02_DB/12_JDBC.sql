SELECT EMP_NAME, SALARY, JOB_CODE, HIRE_DATE FROM EMPLOYEE

-- 300만 이상
SELECT EMP_ID, EMP_NAME, SALARY, HIRE_DATE
FROM EMPLOYEE
WHERE SALARY >= 3000000
ORDER BY SALARY DESC;

-- 부서명이 총무부인 부서에 존재하는 사원의 
-- 사번, 이름, 급여, 부서명을 사번 오름차순으로 조회
SELECT EMP_ID, EMP_NAME, SALARY, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE DEPT_TITLE = '총무부'
ORDER BY EMP_ID;

-- NULL 값 구할 때 (잘 안 쓰는 방법)
SELECT * FROM (
				SELECT EMP_ID, EMP_NAME, SALARY, NVL(DEPT_TITLE, 'NULL') DEPT_TITLE
				FROM EMPLOYEE
				LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
				WHERE DEPT_CODE IS NULL
				ORDER BY EMP_ID)
WHERE DEPT_TITLE = 'NULL';


-- 직급명을 입력 받아 일치하는 사원의
-- 부서명, 직급명, 이름, 이메일을  이름 오름 차순으로 조회
SELECT NVL(DEPT_TITLE, '부서없음'), JOB_NAME, EMP_NAME, EMAIL
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_ID = DEPT_CODE)
LEFT JOIN JOB USING (JOB_CODE)
WHERE JOB_NAME = ''
ORDER BY EMP_NAME;

-- 사번, 이름, 직급명, 급여 조회
-- 급여 내림차순
SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY 
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
WHERE SALARY BETWEEN 3000000 AND 6000000
ORDER BY SALARY DESC;

-- 입력 2개
-- 조회 결과 N행 (List 필요)

COMMIT;

SELECT MAX(EMP_ID) FROM EMPLOYEE;

-- 사번 생성 시퀀스(223번 시작)
CREATE SEQUENCE SEQ_EMP_ID
START WITH 223  -- 223번 시작
INCREMENT BY 1 -- 1씩 증가
NOCYCLE -- 반복 없음
NOCACHE; -- 미리 만들어두는 번호 없음

-- SEQ_EMP_ID.NEXTVAL : 다음 번호 생성
-- SEQ_EMP_ID.CURRVAL : 현재 번호 조회


UPDATE EMPLOYEE 
SET EMAIL = ?,
	PHONE = ?,
	SALARY = ?
WHERE EMP_ID = ?;

SELECT EMP_ID, EMP_NAME, PHONE, EMAIL, SALARY, JOB_NAME
FROM EMPLOYEE 
NATURAL JOIN JOB
WHERE EMP_ID = 223;


UPDATE EMPLOYEE 
SET ENT_YN = 'Y', ENT_DATE = SYSDATE 
WHERE EMP_ID = 223;

SELECT * FROM EMPLOYEE
WHERE EMP_ID = 223;



---------------------------------------------------------
/*JDBC HOMEWORK*/

-- 1. 
SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY, PHONE, EMAIL
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_ID = DEPT_CODE)
JOIN JOB USING (JOB_CODE)
WHERE ENT_YN = 'N'
ORDER BY JOB_CODE;

-- 2.
SELECT EMP_ID, EMP_NAME, NVL(PHONE, '없음') PHONE, EMAIL, TO_CHAR(ENT_DATE, 'YYYY"년" MM"월" DD"일"') ENT_DATE 
FROM EMPLOYEE
WHERE ENT_YN = 'Y'
ORDER BY ENT_DATE;

-- 3. 
SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY, PHONE, EMAIL, HIRE_DATE, ENT_YN
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_ID = DEPT_CODE)
JOIN JOB USING (JOB_CODE)
WHERE EMP_ID = ?;

-- 5.
UPDATE EMPLOYEE 
SET EMAIL = ?, PHONE = ?, SALARY = ?, BONUS = ?
WHERE EMP_ID = ?;

-- 6.
DELETE FROM EMPLOYEE
WHERE EMP_ID = ?;

-- 7. 
UPDATE EMPLOYEE 
SET ENT_YN = 'Y', ENT_DATE = SYSDATE 
WHERE EMP_ID = ?;

-- 8. 
SELECT *
FROM (SELECT EMP_ID, EMP_NAME, DEPT_TITLE, HIRE_DATE, RANK() OVER(ORDER BY HIRE_DATE DESC) 순위
	  FROM EMPLOYEE
	  JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID))
WHERE 순위 <= 5;

-- ROWNUM, 인라인뷰(FROM절 서브쿼리)
SELECT * 
FROM (SELECT EMP_ID, EMP_NAME, NVL(DEPT_TITLE, '부서없음') DEPT_TITLE, HIRE_DATE
	FROM EMPLOYEE
	LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
	ORDER BY HIRE_DATE DESC)
WHERE ROWNUM <= 5;

-- 9. 
SELECT DEPT_CODE, NVL(DEPT_TITLE, '부서 없음') DEPT_TITLE, COUNT(*) 인원, FLOOR(AVG(SALARY)) 평균
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
GROUP BY DEPT_CODE, DEPT_TITLE
ORDER BY DEPT_CODE;



--
SELECT * FROM EMPLOYEE 
WHERE EMP_NAME = '김개똥';

ROLLBACK;

SELECT * FROM EMPLOYEE 
WHERE EMP_ID = 200;



-- 입력 받은 사번의 사원이 존재하지 않으면 0
-- 사원은 있는데 퇴직처리된 사원이면 1
-- 사원도 있고, 재직 중인 사원이면 2 조회
SELECT CASE 
			-- 존재하지 않는 사원?
			WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 300) = 0
			THEN 0
			
			-- 존재하지만 퇴직한 사원?
			WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 300 AND ENT_YN = 'Y') = 1
			THEN 1
			
			-- 존재하고 퇴직하지 않은 사원!
			ELSE 2
		END "CHECK"
FROM DUAL;

SELECT CASE 
			WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 300) = 0
			THEN 0
			WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 300 AND ENT_YN = 'Y') = 1
			THEN 1
			ELSE 2
		END "CHECK"
FROM DUAL;












